name: Build, Tag & Release Docker Image

on:
  push:
    branches:
      - main

permissions:
  contents: write
  packages: write

jobs:
  # 1. Derive a CalVer-style tag (YYYY.MM.DD-<run_number>)
  tag:
    name: Create Git Tag
    runs-on: ubuntu-latest
    outputs:
      new_tag: ${{ steps.set_tag.outputs.new_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Generate tag name
        id: set_tag
        run: |
          TAG="$(date -u +'%Y.%m.%d')-${{ github.run_number }}"
          echo "new_tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "${{ steps.set_tag.outputs.new_tag }}"
          git push origin "${{ steps.set_tag.outputs.new_tag }}"

  # 2. Build & push a single multi-arch Docker image
  build:
    name: Build Multi-arch Image
    runs-on: ubuntu-latest
    needs: tag
    env:
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Lowercase image name
        id: image
        run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          # We build for both major architectures at once
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ env.REGISTRY }}/${{ steps.image.outputs.name }}:${{ needs.tag.outputs.new_tag }}
            ${{ env.REGISTRY }}/${{ steps.image.outputs.name }}:latest

  # 3. Create a GitHub Release
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [tag, build]
    env:
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Lowercase image name
        id: image
        run: echo "name=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.tag.outputs.new_tag }}
          name: "Release ${{ needs.tag.outputs.new_tag }}"
          body: |
            ## NixOS Swarm Node ISO Builder â€” ${{ needs.tag.outputs.new_tag }}

            A truly multi-arch Docker image is available on GHCR, supporting both `x86_64` (amd64) and `aarch64` (arm64) architectures out of the box.

            Pull the image:
            ```bash
            docker pull ${{ env.REGISTRY }}/${{ steps.image.outputs.name }}:${{ needs.tag.outputs.new_tag }}
            # or
            docker pull ${{ env.REGISTRY }}/${{ steps.image.outputs.name }}:latest
            ```

            ### Usage
            ```bash
            docker run --rm \
              -v "$(pwd)/out:/out" \
              ${{ env.REGISTRY }}/${{ steps.image.outputs.name }}:latest \
              <MANAGER_IP> <SWARM_TOKEN> [TARGET_DISK] [ARCH]
            ```
            
            By default, the image builds an ISO matching your host's architecture. You can explicitly specify the target architecture as the 4th argument (e.g., `x86_64-linux` or `aarch64-linux`).
            
            Docker will automatically run the appropriate version of the builder for your system.
          generate_release_notes: true
